// Generated by CoffeeScript 1.7.1
(function() {
  var BacklogDB, BodyParser, CoffeeScript, Config, CookieParser, Crypto, Eco, Engine, Express, Fs, Gzippo, Http, Https, LocalStrategy, Log, MethodOverride, Morgan, Passport, PasswordHash, Path, ServeStatic, SessionStore, Url, User, Util, WebSocket, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  WorkingQueue = require('capisce').WorkingQueue;

  Http = require('http');

  Https = require('https');

  Passport = require('passport');

  LocalStrategy = require('passport-local').Strategy;

  Url = require('url');

  WebSocket = require('faye-websocket');

  PasswordHash = require('password-hash');

  CoffeeScript = require('coffee-script');

  Util = require('util');

  Crypto = require('crypto');

  _ = require('underscore');

  Gzippo = require('gzippo');

  Eco = require('eco');

  Express = require('express');

  Morgan = require('morgan');

  CookieParser = require('cookie-parser');

  BodyParser = require('body-parser');

  MethodOverride = require('method-override');

  ServeStatic = require('serve-static');

  Log = require('./log');

  Config = require('./config');

  User = require('./user');

  BacklogDB = require('./backlog_db');

  SessionStore = require('./session_store');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Engine = (function() {
    function Engine(config, callback) {
      this.users = [];
      this.port = config.port;
      this.db = new BacklogDB((function(_this) {
        return function() {
          return _this.finishLoading(callback);
        };
      })(this));
      this.sslDisabled = config.sslDisabled;
    }

    Engine.prototype.finishLoading = function(callback) {
      this.startServer(this.port, callback);
      return this.db.selectUsers((function(_this) {
        return function(users) {
          var userInfo, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = users.length; _i < _len; _i++) {
            userInfo = users[_i];
            _results.push(_this.addUser(userInfo));
          }
          return _results;
        };
      })(this));
    };

    Engine.prototype.startServer = function(port, callback) {
      var checkSession, restrict, restrict_admin, sessionChecker;
      Passport.use(new LocalStrategy((function(_this) {
        return function(username, password, done) {
          return _this.db.selectUserByName(username, function(userInfo) {
            if (userInfo == null) {
              return done(null, false, {
                message: 'Invalid username'
              });
            }
            if (!PasswordHash.verify(password, userInfo.password)) {
              return done(null, false, {
                message: 'Invalid password'
              });
            }
            return done(null, userInfo);
          });
        };
      })(this)));
      this.sessions = new SessionStore(Path.join(Config.getDataDirectory(), 'sessions.json'));
      this.app = Express();
      sessionChecker = (function(_this) {
        return function(req, res, next) {
          return checkSession(req.cookies.session, function(session, user) {
            if (user == null) {
              res.clearCookie('session', {
                secure: true,
                path: '/'
              });
            }
            if (user == null) {
              res.clearCookie('session', {
                secure: true,
                path: '/chat'
              });
            }
            return next();
          });
        };
      })(this);
      if (Log.level === 'silly') {
        this.app.use(Morgan('combined'));
      }
      this.app.use(CookieParser());
      this.app.use(BodyParser());
      this.app.use(MethodOverride());
      this.app.use(Passport.initialize());
      this.app.use(sessionChecker);
      this.app.use(ServeStatic(__dirname + '/../../web'));
      this.app.use(Gzippo.compress());
      this.app.set('views', __dirname + '/../../web');
      this.app.engine('eco', function(path, options, fn) {
        return Fs.readFile(path, 'utf8', function(err, str) {
          if (err) {
            return fn(err);
          }
          str = Eco.render(str, options);
          return fn(null, str);
        });
      });
      checkSession = (function(_this) {
        return function(sessionId, callback) {
          var session, user;
          session = _this.sessions.get(sessionId);
          if (session == null) {
            return callback(null);
          }
          user = _this.users[session.uid];
          if (user == null) {
            _this.sessions.destroy(sessionId);
            return callback(null, null);
          }
          return callback(session, user);
        };
      })(this);
      restrict = (function(_this) {
        return function(req, res, next) {
          return checkSession(req.cookies.session, function(session, user) {
            if (!user) {
              res.send(401, 'Unauthorized');
              return;
            }
            req.session = session;
            req.user = user;
            return next();
          });
        };
      })(this);
      restrict_admin = function(req, res, next) {
        return restrict(req, res, (function(_this) {
          return function() {
            if (!req.user.is_admin) {
              return res.send(401, 'Unauthorized');
            } else {
              return next();
            }
          };
        })(this));
      };
      this.app.post('/chat/login', (function(_this) {
        return function(req, res) {
          var auth;
          if (req.body.email != null) {
            req.body.username = req.body.email;
          }
          if (req.body.username == null) {
            req.body.username = 'user';
          }
          auth = Passport.authenticate('local', function(err, user, info) {
            var response, sessionId;
            if (err) {
              return next(err);
            }
            if (!user) {
              response = {
                success: false,
                message: info.message
              };
              res.json(response, 401);
            }
            if (user) {
              sessionId = Crypto.randomBytes(32).toString('hex');
              _this.sessions.set(sessionId, {
                uid: user.uid
              });
              response = {
                success: true,
                session: sessionId,
                user: {
                  id: user.uid,
                  name: user.name,
                  is_admin: user.is_admin === 1
                }
              };
              return res.json(response);
            }
          });
          return auth(req, res);
        };
      })(this));
      this.app.post('/chat/logout', restrict, (function(_this) {
        return function(req, res) {
          _this.sessions.destroy(req.cookies.session);
          return res.json({
            success: true
          });
        };
      })(this));
      this.app.post('/chat/change-password', restrict, (function(_this) {
        return function(req, res) {
          var newpassword, oldpassword;
          oldpassword = req.body.oldpassword;
          newpassword = req.body.newpassword;
          if (!((newpassword != null) && newpassword.length >= 8)) {
            res.json({
              success: false,
              message: 'New password is too short.'
            }, 400);
            return;
          }
          return _this.db.selectUser(req.session.uid, function(userInfo) {
            if (!PasswordHash.verify(oldpassword, userInfo.password)) {
              res.json({
                success: false,
                message: 'Incorrect old password.'
              }, 400);
              return;
            }
            return _this.db.updateUser(req.session.uid, {
              password_hash: PasswordHash.generate(newpassword)
            }, function(row) {
              return res.json({
                success: true
              });
            });
          });
        };
      })(this));
      this.app.get('/chat/backlog', restrict, (function(_this) {
        return function(req, res) {
          var beforeid, bid, cid, events, num, user;
          user = req.user;
          bid = req.param('bid');
          cid = req.param('cid');
          if (bid && cid) {
            num = req.param('num') || 150;
            beforeid = req.param('beforeid');
            return _this.db.selectEventsRange(cid, bid, num, beforeid, function(rows) {
              var row;
              rows = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = rows.length; _i < _len; _i++) {
                  row = rows[_i];
                  _results.push(merge({
                    eid: row.eid,
                    time: row.created_at
                  }, JSON.parse(row.data)));
                }
                return _results;
              })();
              return res.json(rows);
            });
          } else {
            events = [];
            return user.getBacklog((function(event) {
              return events.push(user.prepareMessage(event));
            }), function() {
              return res.json(events);
            });
          }
        };
      })(this));
      this.app.get('/admin/users', restrict_admin, (function(_this) {
        return function(req, res) {
          var uid, user, users;
          user = req.user;
          users = (function() {
            var _ref1, _results;
            _ref1 = this.users;
            _results = [];
            for (uid in _ref1) {
              user = _ref1[uid];
              _results.push(user.asJson());
            }
            return _results;
          }).call(_this);
          return res.json(users);
        };
      })(this));
      this.app.post('/admin/users', restrict_admin, (function(_this) {
        return function(req, res) {
          var isAdmin, name, password;
          name = req.body.name;
          password = req.body.password;
          isAdmin = req.body.is_admin === 'true';
          return _this.db.insertUser(name, PasswordHash.generate(password), isAdmin, function(row) {
            var user;
            user = _this.addUser(row);
            return res.json({
              success: true,
              user: user.asJson()
            });
          });
        };
      })(this));
      this.app.put('/admin/users/:user_id', restrict_admin, (function(_this) {
        return function(req, res) {
          var user;
          user = _this.users[req.param('user_id')];
          return user.edit({
            password_hash: PasswordHash.generate(req.body.password),
            is_admin: req.body.is_admin === 'true' ? 1 : 0
          }, function() {
            return res.json({
              success: true
            });
          });
        };
      })(this));
      this.app["delete"]('/admin/users/:user_id', restrict_admin, (function(_this) {
        return function(req, res) {
          var user;
          user = _this.users[req.param('user_id')];
          return _this.deleteUser(user, function() {
            var session, session_id, _ref1;
            _ref1 = _this.sessions.all();
            for (session_id in _ref1) {
              session = _ref1[session_id];
              if (session.uid === user.id) {
                _this.sessions.destroy(session_id);
              }
            }
            return res.json({
              success: true
            });
          });
        };
      })(this));
      if (!this.sslDisabled) {
        this.web = Https.createServer({
          key: Fs.readFileSync(Config.getCertFile()),
          cert: Fs.readFileSync(Config.getCertFile())
        }, this.app);
      } else {
        this.web = Http.createServer(this.app);
      }
      this.web.addListener('upgrade', (function(_this) {
        return function(req, socket, head) {
          var res;
          req.method = 'UPGRADE';
          res = new Http.ServerResponse(req);
          res.assignSocket(socket);
          return _this.app.handle(req, res, function() {
            return restrict(req, res, function() {
              var ws;
              ws = new WebSocket(req, socket, head);
              return req.user.addClient(ws, req.param('inband', false));
            });
          });
        };
      })(this));
      return this.web.listen(port, '::', (function(_this) {
        return function() {
          console.log("\nTapChat ready at https://localhost:" + port + "\n");
          if (callback) {
            return callback(_this);
          }
        };
      })(this));
    };

    Engine.prototype.addUser = function(userInfo) {
      var user;
      user = new User(this, userInfo);
      return this.users[user.id] = user;
    };

    Engine.prototype.deleteUser = function(user, cb) {
      return user["delete"]((function(_this) {
        return function() {
          _this.users.splice(_this.users.indexOf(user), 1);
          if (cb) {
            return cb();
          }
        };
      })(this));
    };

    return Engine;

  })();

  module.exports = Engine;

}).call(this);

//# sourceMappingURL=engine.map
